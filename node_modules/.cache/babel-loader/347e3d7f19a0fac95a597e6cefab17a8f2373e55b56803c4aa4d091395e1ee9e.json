{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { magicEdenAPI, ethPriceAPI, fallbackCollections } from '../services/apiService';\nexport const useNFTData = () => {\n  _s();\n  const [collections, setCollections] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [ethPrice, setEthPrice] = useState(0);\n  const [trendingCollections, setTrendingCollections] = useState([]);\n  const [userPortfolio, setUserPortfolio] = useState([]);\n  const [userAddress, setUserAddress] = useState('');\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const fetchCollections = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Fetch from Magic Eden API\n      const [collectionsData, trendingData] = await Promise.all([magicEdenAPI.getCollections(20), magicEdenAPI.getTrendingCollections('1d', 20)]);\n      if (collectionsData && collectionsData.length > 0) {\n        setCollections(collectionsData);\n      } else {\n        setCollections(fallbackCollections);\n      }\n      if (trendingData && trendingData.length > 0) {\n        setTrendingCollections(trendingData);\n      }\n      setLastUpdated(new Date());\n    } catch (err) {\n      console.error('Error fetching collections:', err);\n      setError('Failed to fetch NFT data');\n      setCollections(fallbackCollections);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  const fetchETHPrice = useCallback(async () => {\n    try {\n      const price = await ethPriceAPI.getETHPrice();\n      setEthPrice(price);\n    } catch (err) {\n      console.error('Error fetching ETH price:', err);\n    }\n  }, []);\n  const fetchUserPortfolio = useCallback(async address => {\n    if (!address) return;\n    try {\n      const portfolio = await magicEdenAPI.getUserCollections(address);\n      setUserPortfolio(portfolio);\n    } catch (err) {\n      console.error('Error fetching user portfolio:', err);\n    }\n  }, []);\n  useEffect(() => {\n    fetchCollections();\n    fetchETHPrice();\n\n    // Refresh data every 2 minutes\n    const interval = setInterval(() => {\n      fetchCollections();\n      fetchETHPrice();\n    }, 120000);\n    return () => clearInterval(interval);\n  }, [fetchCollections, fetchETHPrice]);\n  useEffect(() => {\n    if (userAddress) {\n      fetchUserPortfolio(userAddress);\n    }\n  }, [userAddress, fetchUserPortfolio]);\n  const refreshData = useCallback(() => {\n    fetchCollections();\n    fetchETHPrice();\n    if (userAddress) {\n      fetchUserPortfolio(userAddress);\n    }\n  }, [fetchCollections, fetchETHPrice, fetchUserPortfolio, userAddress]);\n  return {\n    collections,\n    trendingCollections,\n    userPortfolio,\n    loading,\n    error,\n    ethPrice,\n    lastUpdated,\n    refreshData,\n    setUserAddress\n  };\n};\n_s(useNFTData, \"41nSewS3i157gFuBmU+c8AglTkY=\");","map":{"version":3,"names":["useState","useEffect","useCallback","magicEdenAPI","ethPriceAPI","fallbackCollections","useNFTData","_s","collections","setCollections","loading","setLoading","error","setError","ethPrice","setEthPrice","trendingCollections","setTrendingCollections","userPortfolio","setUserPortfolio","userAddress","setUserAddress","lastUpdated","setLastUpdated","fetchCollections","collectionsData","trendingData","Promise","all","getCollections","getTrendingCollections","length","Date","err","console","fetchETHPrice","price","getETHPrice","fetchUserPortfolio","address","portfolio","getUserCollections","interval","setInterval","clearInterval","refreshData"],"sources":["C:/Personal/nft-dashboard/src/hooks/useNFTData.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { magicEdenAPI, ethPriceAPI, fallbackCollections } from '../services/apiService';\n\nexport const useNFTData = () => {\n  const [collections, setCollections] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [ethPrice, setEthPrice] = useState(0);\n  const [trendingCollections, setTrendingCollections] = useState([]);\n  const [userPortfolio, setUserPortfolio] = useState([]);\n  const [userAddress, setUserAddress] = useState('');\n  const [lastUpdated, setLastUpdated] = useState(null);\n\n  const fetchCollections = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      // Fetch from Magic Eden API\n      const [collectionsData, trendingData] = await Promise.all([\n        magicEdenAPI.getCollections(20),\n        magicEdenAPI.getTrendingCollections('1d', 20)\n      ]);\n      \n      if (collectionsData && collectionsData.length > 0) {\n        setCollections(collectionsData);\n      } else {\n        setCollections(fallbackCollections);\n      }\n      \n      if (trendingData && trendingData.length > 0) {\n        setTrendingCollections(trendingData);\n      }\n      \n      setLastUpdated(new Date());\n    } catch (err) {\n      console.error('Error fetching collections:', err);\n      setError('Failed to fetch NFT data');\n      setCollections(fallbackCollections);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const fetchETHPrice = useCallback(async () => {\n    try {\n      const price = await ethPriceAPI.getETHPrice();\n      setEthPrice(price);\n    } catch (err) {\n      console.error('Error fetching ETH price:', err);\n    }\n  }, []);\n\n  const fetchUserPortfolio = useCallback(async (address) => {\n    if (!address) return;\n    \n    try {\n      const portfolio = await magicEdenAPI.getUserCollections(address);\n      setUserPortfolio(portfolio);\n    } catch (err) {\n      console.error('Error fetching user portfolio:', err);\n    }\n  }, []);\n\n  useEffect(() => {\n    fetchCollections();\n    fetchETHPrice();\n    \n    // Refresh data every 2 minutes\n    const interval = setInterval(() => {\n      fetchCollections();\n      fetchETHPrice();\n    }, 120000);\n    \n    return () => clearInterval(interval);\n  }, [fetchCollections, fetchETHPrice]);\n\n  useEffect(() => {\n    if (userAddress) {\n      fetchUserPortfolio(userAddress);\n    }\n  }, [userAddress, fetchUserPortfolio]);\n\n  const refreshData = useCallback(() => {\n    fetchCollections();\n    fetchETHPrice();\n    if (userAddress) {\n      fetchUserPortfolio(userAddress);\n    }\n  }, [fetchCollections, fetchETHPrice, fetchUserPortfolio, userAddress]);\n\n  return {\n    collections,\n    trendingCollections,\n    userPortfolio,\n    loading,\n    error,\n    ethPrice,\n    lastUpdated,\n    refreshData,\n    setUserAddress\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}